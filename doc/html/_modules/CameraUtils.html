<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" />

    <!-- Generated with Sphinx 7.4.7 and Furo 2024.08.06 -->
        <title>CameraUtils - CV-Project-2024 September 2024 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">CV-Project-2024 September 2024 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">CV-Project-2024 September 2024 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Content:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../setup.html">Set up the project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../conf.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CameraUtils.html">CameraUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">Resources</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for CameraUtils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">termcolor</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.patheffects</span> <span class="k">as</span> <span class="nn">path_effects</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">configuration</span> <span class="k">as</span> <span class="nn">conf</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>


<div class="viewcode-block" id="Camera">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera">[docs]</a>
<span class="k">class</span> <span class="nc">Camera</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class used to represent the calibration process of a camera using chessboard images.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    camera_number : int</span>
<span class="sd">        The identifier number for the camera being calibrated.</span>
<span class="sd">    FISHEYE : bool</span>
<span class="sd">        A flag indicating if the camera is a WideLens.</span>
<span class="sd">    chessboard_size : tuple or None</span>
<span class="sd">        The number of inner corners per chessboard row and column (e.g., (7, 6)).</span>
<span class="sd">    obj_points : list</span>
<span class="sd">        The 3D points in the real-world space.</span>
<span class="sd">    img_points : list</span>
<span class="sd">        The 2D points in the image plane.</span>
<span class="sd">    mtx : numpy.ndarray or None</span>
<span class="sd">        The camera matrix.</span>
<span class="sd">    dist : numpy.ndarray or None</span>
<span class="sd">        The distortion coefficients.</span>
<span class="sd">    rvecs : list or None</span>
<span class="sd">        The rotation vectors estimated for each pattern view.</span>
<span class="sd">    tvecs : list or None</span>
<span class="sd">        The translation vectors estimated for each pattern view.</span>
<span class="sd">    new_mtx : numpy.ndarray or None</span>
<span class="sd">        The refined camera matrix used for undistortion.</span>
<span class="sd">    INT_CAL : bool</span>
<span class="sd">        A flag indicating whether the camera has intrinsic calibration.</span>
<span class="sd">    EXT_CAL : bool</span>
<span class="sd">        A flag indicating whether the camera has extrinsic calibration.</span>
<span class="sd">    img_size : list</span>
<span class="sd">        The size of the images used for calibration (h, w, channels).</span>
<span class="sd">    roi : tuple or None</span>
<span class="sd">        The region of interest for the undistorted images.</span>
<span class="sd">    corr_world_points : numpy.ndarray or None</span>
<span class="sd">        A numpy array of points in 3D space, in the court reference frame.</span>
<span class="sd">    corr_image_points : numpy.ndarray or None</span>
<span class="sd">        A numpy array of points in the 2D image coordinates corresponding to</span>
<span class="sd">        the real-world points (corr_world_points).</span>
<span class="sd">    ext_mtx : numpy.ndarray or None</span>
<span class="sd">        The matrix representing the camera-to-world transformation.</span>
<span class="sd">    H_mtx : numpy.ndarray</span>
<span class="sd">        The homography matrix between the court and image plane.</span>
<span class="sd">    rep_err : float or None</span>
<span class="sd">        The overall reprojection error after intrinsic calibration, representing the quality of the calibration.</span>
<span class="sd">    pos_err : numpy.ndarray</span>
<span class="sd">        A vector representing the positional error in 3D space after extrinsic calibration, initialized to zeros.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __init__(camera_number, approximate_position, WIDE_LENS=False)</span>
<span class="sd">        Initializes the Camera object with a specific camera number, an approximate position in the real world,</span>
<span class="sd">        and whether or not it is WideLens. Sets all other attributes to default values.</span>

<span class="sd">    GetSampleFrames(video_dir, frame_skip, out_dir)</span>
<span class="sd">        Extracts sample frames from a video to use for camera calibration.</span>

<span class="sd">    GetCornersFromSamples(sample_folder)</span>
<span class="sd">        Reads existing images from a folder of existing samples to use for camera calibration.</span>

<span class="sd">    CalibrateCamera()</span>
<span class="sd">        Performs intrinsic calibration of the camera and sets the status to calibrated.</span>

<span class="sd">    SaveParameters(save_dir)</span>
<span class="sd">        Saves camera parameters to a .yaml file.</span>

<span class="sd">    ReadParameters(param_dir)</span>
<span class="sd">        Reads camera parameters from a .yaml file.</span>

<span class="sd">    NewOptimalCameraMatrix()</span>
<span class="sd">        Refines the camera matrix for the undistorsion.</span>

<span class="sd">    TestUndistorsion()</span>
<span class="sd">        Applies undistorsion to the image and shows the effect on an example.</span>

<span class="sd">    GetCorrespondences(world_points, image_path)</span>
<span class="sd">        Obtain correspondences between world points and image points through</span>
<span class="sd">        a manual user interface.</span>

<span class="sd">    AddManualCorrespondences(world_points, image_points)</span>
<span class="sd">        Manually add corresponding points to camera attributes.</span>

<span class="sd">    ExtCalibration()</span>
<span class="sd">        Perform external camera calibration to compute the transformation matrices</span>
<span class="sd">        between the world and camera coordinates, also compute the homography </span>
<span class="sd">        matrix that map the image and court planes.</span>

<span class="sd">    PosError()</span>
<span class="sd">        Calculate and display the positional error between the approximate</span>
<span class="sd">        and estimated positions</span>

<span class="sd">    SaveErrors(`camera_list`, path)</span>
<span class="sd">        *This is a class method.*</span>
<span class="sd">        Save the positional and re-projection errors of a list of cameras to a CSV file</span>

<span class="sd">    PlotCamera(ax)</span>
<span class="sd">        Plot the camera&#39;s position and direction on a 3D axis. *This method is intended to be called by `PlotMultipleCameras()` class method</span>

<span class="sd">    PlotMultipleCameras(camera_list)</span>
<span class="sd">        *This is a class method*</span>
<span class="sd">        Plot the positions and orientations of multiple cameras on a 3D plot.</span>

<span class="sd">    PlotCamera2D(ax)</span>
<span class="sd">        Plot the camera&#39;s position and direction on an axis. *This method is intended to be called by `PlotMultipleCameras2D()` class method.</span>

<span class="sd">    PlotMultipleCameras2D(camera_list)</span>
<span class="sd">        *This is a class method*</span>
<span class="sd">        Plot the positions and orientations of multiple cameras on a 2D court image.</span>

<span class="sd">    PrintAttributes(skip_attributes)</span>
<span class="sd">        Prints all the attributes of the CameraInfo instance, except for those in the skip_attributes list.</span>
<span class="sd">        Method useful for quick attributes checks/debugging</span>

<span class="sd">    FindHomography()</span>
<span class="sd">        Compute the homography matrix from world coordinates (court plane) to image coordinates.</span>

<span class="sd">    Court2Image(coords)</span>
<span class="sd">        Convert court coordinates to image coordinates using the homography matrix</span>

<span class="sd">    Image2Court(coords)</span>
<span class="sd">        Convert image coordinates to court coordinates using the homography matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Camera.__init__">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">camera_number</span><span class="p">,</span>
        <span class="n">approximate_position</span><span class="p">,</span>
        <span class="n">WIDE_LENS</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the CameraCalibration object with a specific camera number</span>
<span class="sd">        and sets default values for other attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        camera_number : int</span>
<span class="sd">            The identifier number for the camera being calibrated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span> <span class="o">=</span> <span class="n">camera_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FISHEYE</span> <span class="o">=</span> <span class="n">WIDE_LENS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rvecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tvecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">INT_CAL</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EXT_CAL</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_world_points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_image_points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C2W_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W2C_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">camera_position</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">approximate_position</span> <span class="o">=</span> <span class="n">approximate_position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rep_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>


<div class="viewcode-block" id="Camera.GetSampleFrames">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.GetSampleFrames">[docs]</a>
    <span class="k">def</span> <span class="nf">GetSampleFrames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video_dir</span><span class="p">,</span> <span class="n">frame_skip</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts sample frames from a video to use for camera calibration.</span>

<span class="sd">        This method reads a video file, samples frames at specified intervals,</span>
<span class="sd">        and detects chessboard corners in these frames. It then saves the frames</span>
<span class="sd">        and the detected points to be used for camera calibration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        video_dir : str</span>
<span class="sd">            The directory where the video file is located.</span>
<span class="sd">        frame_skip : int</span>
<span class="sd">            The number of frames to skip between each sampled frame.</span>
<span class="sd">        out_dir : str</span>
<span class="sd">            The directory where the sampled frames will be saved.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        FileNotFoundError</span>
<span class="sd">            If the specified video file does not exist.</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the video file cannot be opened or read.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The video file is expected to be named in a specific format:</span>
<span class="sd">            &quot;out{camera_number}F{format}&quot;,</span>
<span class="sd">            where &#39;camera_number&#39; is the identifier</span>
<span class="sd">            of the camera and &#39;format&#39; is defined in the configuration</span>
<span class="sd">            (example &#39;out3F.mp4&#39; for camera number 3)</span>
<span class="sd">        - The method uses a chessboard pattern to detect corners in the frames.</span>
<span class="sd">        - It divides the frame into quadrants and saves a specified number of</span>
<span class="sd">            sample frames from each quadrant:</span>
<span class="sd">            - TL: Top-Left</span>
<span class="sd">            - TR: Top-Right</span>
<span class="sd">            - BL: Bottom-Left</span>
<span class="sd">            - BR: Bottom-Right</span>

<span class="sd">        - The method stops when the required number of samples from all</span>
<span class="sd">            quadrants have been collected. The required number of steps can be</span>
<span class="sd">            set in the setting script NUM_OF_SAMPLES.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Initiating frame sampling for camera number </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># create string with filename and add to the file path</span>
        <span class="n">VIDEO_NAME</span> <span class="o">=</span> <span class="s2">&quot;/out&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;F&quot;</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">video_dir</span> <span class="o">+</span> <span class="n">VIDEO_NAME</span> <span class="o">+</span> <span class="n">conf</span><span class="o">.</span><span class="n">FORMAT</span>
        <span class="n">objp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">objp</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span>
            <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># open video</span>
        <span class="n">video_capture</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="c1"># set frame counter</span>
        <span class="n">frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Print the number of frames in the video</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of frames in the video: </span><span class="si">{</span><span class="n">video_capture</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">CAP_PROP_FRAME_COUNT</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Save sampled frames to folder</span>
        <span class="n">sample_dir</span> <span class="o">=</span> <span class="n">out_dir</span> <span class="o">+</span> <span class="n">VIDEO_NAME</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">sample_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">sample_dir</span><span class="p">)</span>
        <span class="c1"># clear folder from previous samples</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">sample_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sample_dir</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span>
        <span class="c1"># Dictionary of quadrant</span>
        <span class="n">quadrant_frame_counter</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;TL&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;BL&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;TR&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;BR&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>  <span class="c1"># is a dictionary the best??</span>
        <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">NUM_OF_SAMPLES</span><span class="p">:</span>
            <span class="n">num_of_samples</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">NUM_OF_SAMPLES</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of samples not specified, using default value of 1&quot;</span><span class="p">)</span>
            <span class="n">num_of_samples</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Start loop</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">video_capture</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="c1"># save image size to camera info</span>
            <span class="k">if</span> <span class="n">frame_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">shape</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
                <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="s2">&quot;Could not open video successfully&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="c1"># skip frame</span>
            <span class="k">if</span> <span class="n">frame_counter</span> <span class="o">%</span> <span class="n">frame_skip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gray_frame</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

                <span class="c1"># find corner in checkerboard</span>
                <span class="n">found_corners</span><span class="p">,</span> <span class="n">corners</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findChessboardCorners</span><span class="p">(</span>
                    <span class="n">gray_frame</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">,</span> <span class="kc">None</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">found_corners</span><span class="p">:</span>
                    <span class="c1"># Determine in which quadrant is the checkerboard</span>
                    <span class="n">w_half</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">h_half</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">quadrant</span> <span class="o">=</span> <span class="s2">&quot;TL&quot;</span>
                    <span class="k">if</span> <span class="n">corners</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">w_half</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">corners</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h_half</span><span class="p">:</span>
                            <span class="n">quadrant</span> <span class="o">=</span> <span class="s2">&quot;TL&quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">quadrant</span> <span class="o">=</span> <span class="s2">&quot;BL&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">corners</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h_half</span><span class="p">:</span>
                            <span class="n">quadrant</span> <span class="o">=</span> <span class="s2">&quot;TR&quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">quadrant</span> <span class="o">=</span> <span class="s2">&quot;BR&quot;</span>
                    <span class="k">if</span> <span class="n">quadrant_frame_counter</span><span class="p">[</span><span class="n">quadrant</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num_of_samples</span><span class="p">:</span>
                        <span class="c1"># frame_skip= frame_skip*0.5</span>
                        <span class="n">frame_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="n">sample_dir</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">quadrant</span><span class="si">}</span><span class="s2">_frame_</span><span class="si">{</span><span class="n">quadrant_frame_counter</span><span class="p">[</span><span class="n">quadrant</span><span class="p">]</span><span class="si">}</span><span class="s2">.jpg&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">frame_filename</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
                        <span class="n">quadrant_frame_counter</span><span class="p">[</span><span class="n">quadrant</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objp</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">img_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;CAM</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&gt; Quadrant </span><span class="si">{</span><span class="n">quadrant</span><span class="si">}</span><span class="s2">: saved frame </span><span class="si">{</span><span class="n">frame_counter</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># frame_skip= 50</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;CAM</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&gt; Quadrant </span><span class="si">{</span><span class="n">quadrant</span><span class="si">}</span><span class="s2">: already saved </span><span class="si">{</span><span class="n">num_of_samples</span><span class="si">}</span><span class="s2"> samples&quot;</span>
                        <span class="p">)</span>
                <span class="c1"># else:</span>
                <span class="c1"># print(f&quot;No corners found in frame {frame_counter}&quot;)</span>
            <span class="n">frame_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Check if enough samples are saved</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">num_of_samples</span> <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">quadrant_frame_counter</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;CAM</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&gt; Done, saved enough samples for all quadrants&quot;</span>
                <span class="p">)</span>
                <span class="k">break</span>
        <span class="n">video_capture</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>

        <span class="c1"># DONE</span>
        <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Camera </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2"> Done&quot;</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;bold&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Camera.GetCornersFromSamples">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.GetCornersFromSamples">[docs]</a>
    <span class="k">def</span> <span class="nf">GetCornersFromSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_folder</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads existing images from a folder of existing samples to use for camera calibration.</span>

<span class="sd">        This method reads sample images and detects chessboard corners</span>
<span class="sd">        in these frames. It then saves the frames and the detected points</span>
<span class="sd">        to be used for camera calibration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_folder : str</span>
<span class="sd">            The directory where the sampled frames are retrieved.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        FileNotFoundError</span>
<span class="sd">            If the specified sample folder does not exist.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The images are expected to be named in a specific format:</span>
<span class="sd">            &quot;out{camera_number}F{format}&quot;,</span>
<span class="sd">            where &#39;camera_number&#39; is the identifier</span>
<span class="sd">            of the camera and &#39;format&#39; is defined in the configuration</span>
<span class="sd">            (example `out3F.jpg` for camera number 3).</span>
<span class="sd">        - The method uses a chessboard pattern to detect corners in the frames.</span>
<span class="sd">        - It divides the frame into quadrants and saves a specified number of</span>
<span class="sd">            sample frames from each quadrant:</span>
<span class="sd">            - TL: Top-Left</span>
<span class="sd">            - TR: Top-Right</span>
<span class="sd">            - BL: Bottom-Left</span>
<span class="sd">            - BR: Bottom-Right</span>
<span class="sd">        - The method stops when the required number of samples from all</span>
<span class="sd">            quadrants have been collected. The required number of steps can be</span>
<span class="sd">            set in the setting script NUM_OF_SAMPLES.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">sample_folder</span><span class="p">):</span>
            <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder </span><span class="si">{</span><span class="n">sample_folder</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Exiting... cannot open folder.&quot;</span><span class="p">)</span>

        <span class="n">VIDEO_NAME</span> <span class="o">=</span> <span class="s2">&quot;/out&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;F&quot;</span>
        <span class="c1"># prepare objects points</span>
        <span class="n">objp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">objp</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span>
            <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">FISHEYE</span><span class="p">:</span>
            <span class="n">objp</span> <span class="o">*=</span> <span class="n">conf</span><span class="o">.</span><span class="n">SQUARE_SIZE</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">sample_folder</span> <span class="o">+</span> <span class="n">VIDEO_NAME</span>

        <span class="n">criteria</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_EPS</span> <span class="o">+</span> <span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_MAX_ITER</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot open </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">, the folder does not exist&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Exiting... cannot open folder.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">frame</span><span class="p">))</span>
            <span class="n">gray_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">found_corners</span><span class="p">,</span> <span class="n">corners</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findChessboardCorners</span><span class="p">(</span>
                <span class="n">gray_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">,</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">found_corners</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objp</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found corners in sample frame: </span><span class="si">{</span><span class="n">frame</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">corners2</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cornerSubPix</span><span class="p">(</span>
                    <span class="n">gray_img</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">criteria</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">img_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corners2</span><span class="p">)</span>

        <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Camera </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2"> DONE&quot;</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Camera.CalibrateCamera">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.CalibrateCamera">[docs]</a>
    <span class="k">def</span> <span class="nf">CalibrateCamera</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the camera and set the status to calibrated.</span>

<span class="sd">        This method performs the camera calibration process using the collected</span>
<span class="sd">        object points and image points. It computes the camera matrix and</span>
<span class="sd">        distortion coefficients. The calibration process is different for</span>
<span class="sd">        fisheye lenses and standard lenses.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If there is an error during the calibration process.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - For fisheye lenses, it uses `cv2.fisheye.calibrate` and sets the fisheye</span>
<span class="sd">        calibration flags.</span>
<span class="sd">        - For standard lenses, it uses `cv2.calibrateCamera`.</span>
<span class="sd">        - Sets `self.INT_CAL` to True if the calibration is successful.</span>
<span class="sd">        - Prints the calibration status.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span> <span class="ow">is</span> <span class="p">[]:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span>
                <span class="n">SampleFile</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">SAMPLE_FOLDER</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/out</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">F&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Calibrating camera </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;blink&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FISHEYE</span><span class="p">:</span>
            <span class="n">N_OK</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">rvecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_OK</span><span class="p">)]</span>
            <span class="n">tvecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_OK</span><span class="p">)]</span>

            <span class="n">calibration_flags</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">fisheye</span><span class="o">.</span><span class="n">CALIB_RECOMPUTE_EXTRINSIC</span>
                <span class="c1"># + cv2.fisheye.CALIB_CHECK_COND</span>
                <span class="o">+</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fisheye</span><span class="o">.</span><span class="n">CALIB_FIX_SKEW</span>
            <span class="p">)</span>
            <span class="n">img_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

            <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># img = np.expand_dims(np.asarray(self.obj_points), -2)</span>

            <span class="n">rms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvecs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvecs</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fisheye</span><span class="o">.</span><span class="n">calibrate</span><span class="p">(</span>
                <span class="n">obj</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">img_points</span><span class="p">,</span>
                <span class="n">img_size</span><span class="p">,</span>
                <span class="n">K</span><span class="p">,</span>
                <span class="n">D</span><span class="p">,</span>
                <span class="n">rvecs</span><span class="p">,</span>
                <span class="n">tvecs</span><span class="p">,</span>
                <span class="n">calibration_flags</span><span class="p">,</span>
                <span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_EPS</span> <span class="o">+</span> <span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_MAX_ITER</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">rms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">INT_CAL</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Successful calibration&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error occurred during calibration&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">ret</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvecs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvecs</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">calibrateCamera</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">INT_CAL</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Successful calibration&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error occurred during calibration&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Camera.RepError">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.RepError">[docs]</a>
    <span class="k">def</span> <span class="nf">RepError</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the re-projection error given the parameters found in calibration.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The new refined camera matrix is used.</span>

<span class="sd">        If the camera is not calibrated (`INT_CAL` is False),</span>
<span class="sd">        the method will print a message indicating that the re-projection error</span>
<span class="sd">        cannot be calculated and return without performing any calculations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">INT_CAL</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FISHEYE</span><span class="p">:</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="p">)):</span>
                    <span class="c1"># Ensure object points are numpy array of type float64 and correctly shaped</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
                    <span class="p">)</span>

                    <span class="c1"># Convert rvec and tvec to numpy arrays of type float64</span>
                    <span class="n">rvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">tvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                    <span class="c1"># project points</span>
                    <span class="n">img_pnt_rep</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fisheye</span><span class="o">.</span><span class="n">projectPoints</span><span class="p">(</span>
                        <span class="n">objectPoints</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
                        <span class="n">rvec</span><span class="o">=</span><span class="n">rvec</span><span class="p">,</span>
                        <span class="n">tvec</span><span class="o">=</span><span class="n">tvec</span><span class="p">,</span>
                        <span class="n">K</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span>
                        <span class="n">D</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># Reshape img_pnt_rep to match the shape of self.img_points[i]</span>
                    <span class="n">img_pnt_rep</span> <span class="o">=</span> <span class="n">img_pnt_rep</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">img_points_reshaped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">img_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                    <span class="c1"># Calculate error</span>
                    <span class="n">error</span> <span class="o">+=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                        <span class="n">img_points_reshaped</span><span class="p">,</span> <span class="n">img_pnt_rep</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">NORM_L2</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_pnt_rep</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">rep_err</span> <span class="o">=</span> <span class="n">error</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Re-projection error of CAM</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rep_err</span><span class="si">:</span><span class="s2">05.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="p">)):</span>
                    <span class="n">img_pnt_rep</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">projectPoints</span><span class="p">(</span>
                        <span class="n">objectPoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">rvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">tvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">cameraMatrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span>
                        <span class="n">distCoeffs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># Calculate error</span>
                    <span class="n">error</span> <span class="o">+=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">img_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">img_pnt_rep</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">NORM_L2</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_pnt_rep</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">rep_err</span> <span class="o">=</span> <span class="n">error</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_points</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Re-projection error of CAM</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rep_err</span><span class="si">:</span><span class="s2">05.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot calculate re-projection error. CAM</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2"> is not calibrated&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span></div>


<div class="viewcode-block" id="Camera.SaveParameters">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.SaveParameters">[docs]</a>
    <span class="k">def</span> <span class="nf">SaveParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save camera parameters to a .pkl file.</span>

<span class="sd">        This method serializes the Camera object and saves it to a file in the</span>
<span class="sd">        specified directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        save_dir : str</span>
<span class="sd">            The directory where the parameters will be saved.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If the folder does not exist, it is created.</span>
<span class="sd">        - The saved file is named &quot;Camera_{camera_number}.pkl&quot; where</span>
<span class="sd">        `{camera_number}` is the identifier of the camera.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">save_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">save_dir</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_dir</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/Camera_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Camera parameters saved to file&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Camera.LoadCamera">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.LoadCamera">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">LoadCamera</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">param_dir</span><span class="p">,</span> <span class="n">camera</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load camera parameters from a .pkl file.</span>

<span class="sd">        This method deserializes the Camera object from a file in the specified</span>
<span class="sd">        directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param_dir : str</span>
<span class="sd">            The directory where the parameters are stored.</span>
<span class="sd">        camera : str</span>
<span class="sd">            The identifier for the camera to be loaded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Camera</span>
<span class="sd">            The Camera object with the loaded parameters.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        FileNotFoundError</span>
<span class="sd">            If the specified parameter directory does not exist.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method expects the file to be named &quot;Camera_{camera_number}.pkl&quot;</span>
<span class="sd">          where `{camera_number}` is the identifier of the camera.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">param_dir</span><span class="p">):</span>
            <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot open </span><span class="si">{</span><span class="n">param_dir</span><span class="si">}</span><span class="s2">, the folder does not exist&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span>
            <span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Existing... cannot find parameter folder&quot;</span><span class="p">)</span>

        <span class="n">cam_number</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">CAMS</span><span class="p">[</span><span class="n">camera</span><span class="p">][</span><span class="s2">&quot;number&quot;</span><span class="p">]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">param_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Camera_</span><span class="si">{</span><span class="n">cam_number</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">),</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">camera</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Camera parameters read from file and set to camera </span><span class="si">{</span><span class="n">camera</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">camera</span></div>


<div class="viewcode-block" id="Camera.NewOptimalCameraMatrix">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.NewOptimalCameraMatrix">[docs]</a>
    <span class="k">def</span> <span class="nf">NewOptimalCameraMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Refine the camera matrix for the undistortion process.</span>

<span class="sd">        This method computes a new optimal camera matrix based on the current</span>
<span class="sd">        camera matrix and distortion coefficients. It adjusts the camera matrix</span>
<span class="sd">        to improve the undistortion of images.</span>

<span class="sd">        Depending on whether a fisheye lens is used or a standard lens, the</span>
<span class="sd">        method applies different algorithms to compute the new camera matrix:</span>

<span class="sd">        - For fisheye lenses, it uses</span>
<span class="sd">          :func:`cv2.fisheye.estimateNewCameraMatrixForUndistortRectify`.</span>
<span class="sd">        - For standard lenses, it uses :func:`cv2.getOptimalNewCameraMatrix`.</span>

<span class="sd">        The computed camera matrix is stored in `self.new_mtx`. In the case of</span>
<span class="sd">        standard lenses, the method also updates `self.roi` with the region of</span>
<span class="sd">        interest.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Ensure that the `self.img_size`, `self.mtx`, and `self.dist` are</span>
<span class="sd">          correctly set before calling this method.</span>
<span class="sd">        - The `self.FISHEYE` flag determines whether to use the fisheye or</span>
<span class="sd">          standard lens processing approach.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_size</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FISHEYE</span><span class="p">:</span>
            <span class="n">new_camera_mtx</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fisheye</span><span class="o">.</span><span class="n">estimateNewCameraMatrixForUndistortRectify</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">new_size</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new_mtx</span> <span class="o">=</span> <span class="n">new_camera_mtx</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_camera_mtx</span><span class="p">,</span> <span class="n">roi</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getOptimalNewCameraMatrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new_mtx</span> <span class="o">=</span> <span class="n">new_camera_mtx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">=</span> <span class="n">roi</span></div>


<div class="viewcode-block" id="Camera.TestUndistorsion">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.TestUndistorsion">[docs]</a>
    <span class="k">def</span> <span class="nf">TestUndistorsion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test the undistorsion of the camera images.</span>

<span class="sd">        This method reads a sample image, applies the undistorsion process based on</span>
<span class="sd">        the calibration parameters, and visualizes the results. It also saves the</span>
<span class="sd">        undistorted image to a specified directory.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The sample image is read from a predefined folder.</span>
<span class="sd">        - The method checks if the camera is calibrated before proceeding.</span>
<span class="sd">        - If the camera uses a fisheye lens, `cv2.fisheye.undistortImage` is used for undistorsion.</span>
<span class="sd">        - For standard lenses, `cv2.undistort` is used.</span>
<span class="sd">        - If cropping is enabled, the undistorted image is cropped to the region of interest (ROI).</span>
<span class="sd">        - The original and undistorted images are displayed side by side for comparison.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the camera is not calibrated.</span>
<span class="sd">        FileNotFoundError</span>
<span class="sd">            If the sample image is not found.</span>

<span class="sd">        Saves</span>
<span class="sd">        -----</span>
<span class="sd">        - The undistorted image is saved to a predefined directory with the filename &quot;Cam{camera_number}.jpg&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Testing undistorsion of camera </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">SAMPLE_FOLDER</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/out</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">F&quot;</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">SampleFile</span><span class="p">(</span><span class="n">folder</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">INT_CAL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Camera </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2"> is not calibrated, calibrate it first&quot;</span><span class="p">,</span>
                <span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Exiting... camera not calibrated&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FISHEYE</span><span class="p">:</span>
            <span class="n">undst</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fisheye</span><span class="o">.</span><span class="n">undistortImage</span><span class="p">(</span>
                <span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="n">Knew</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">new_mtx</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">undst</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">undistort</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_mtx</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">CROP</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">!=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># crop image</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi</span>
                    <span class="n">undst</span> <span class="o">=</span> <span class="n">undst</span><span class="p">[</span><span class="n">y</span> <span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">w</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot crop the image ROI -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">out_file</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">UNDISTORTED_SAMPLES</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/Cam</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">.jpg&quot;</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">undst</span><span class="p">)</span>

        <span class="c1"># Draw the corners</span>
        <span class="n">g_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="n">ret</span><span class="p">,</span> <span class="n">corners</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findChessboardCorners</span><span class="p">(</span><span class="n">g_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">drawChessboardCorners</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chessboard_size</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>

        <span class="c1"># Visualize un-distortion</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Camera view #</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">. Wide-Lense : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">FISHEYE</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Original Image&quot;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">undst</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Undistorted Image&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">UNDISTORTED_SAMPLES</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/Confront/Cam</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">SHOW_TEST_FRAME</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="Camera.GetCorrespondences">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.GetCorrespondences">[docs]</a>
    <span class="k">def</span> <span class="nf">GetCorrespondences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_points</span><span class="p">,</span> <span class="n">image_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain correspondences between world points and image points through a manual user interface.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        world_points : list of tuples</span>
<span class="sd">            List of world points (x, y, z) that need to be mapped to the image points (They must lie on the court plane, so z=0!).</span>
<span class="sd">        image_path : str</span>
<span class="sd">            Path to the image file in which correspondences need to be identified.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        coords : list of lists</span>
<span class="sd">            List of image coordinates corresponding to the world points. If acquisition is skipped or terminated, returns an empty list.</span>
<span class="sd">            Each coordinate is either a list of two floats [x, y] or [NaN, NaN] if the point is skipped.</span>

<span class="sd">        Notes:</span>
<span class="sd">        ------</span>
<span class="sd">        This function allows the user to manually select corresponding points in the image using a GUI. The user can interact with the GUI to select points, skip points, or terminate the acquisition process.</span>

<span class="sd">        If the camera is not calibrated, the function will print a message and return without acquiring any correspondences.</span>

<span class="sd">        The user can interact with the GUI as follows:</span>
<span class="sd">        - Right-click on the image to select a point.</span>
<span class="sd">        - Press the space bar to skip the current point.</span>
<span class="sd">        - Press &#39;n&#39; to skip the calibration for the current camera.</span>
<span class="sd">        - Press &#39;t&#39; to terminate the point acquisition process.</span>

<span class="sd">        This method uses OpenCV for image processing and Matplotlib for the GUI.</span>

<span class="sd">        Internal Processing:</span>
<span class="sd">        --------------------</span>
<span class="sd">        1. Reads the court plan image and the input image.</span>
<span class="sd">        2. Undistort the input image based on the camera calibration parameters.</span>
<span class="sd">        3. Optionally crops the image based on the region of interest (ROI).</span>
<span class="sd">        4. Transforms world points to court plan coordinates.</span>
<span class="sd">        5. Initiates a GUI for the user to select corresponding points.</span>
<span class="sd">        6. Handles user interactions via mouse clicks and keyboard events.</span>
<span class="sd">        7. Returns the list of acquired coordinates or an empty list if acquisition is skipped/terminated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">COURT</span> <span class="o">=</span> <span class="s2">&quot;./MISC/Court.png&quot;</span>
        <span class="n">courtplan</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">COURT</span><span class="p">)</span>
        <span class="n">SKIP_CAL</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">TERM_ACQ</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">point_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># image_path =</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">INT_CAL</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Camera is not calibrated, cannot un-distort the image&quot;</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FISHEYE</span><span class="p">:</span>
            <span class="n">undst</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fisheye</span><span class="o">.</span><span class="n">undistortImage</span><span class="p">(</span>
                <span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="n">Knew</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mtx</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">undst</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">undistort</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_mtx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">CROP</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cam </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2"> roi is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="si">}</span><span class="s2">, not cropping the image&quot;</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># crop image</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi</span>
                <span class="n">undst</span> <span class="o">=</span> <span class="n">undst</span><span class="p">[</span><span class="n">y</span> <span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">w</span><span class="p">]</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">world_points</span><span class="p">)</span>
        <span class="c1"># Get translation vector form RW to Img transformation</span>
        <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">courtplan</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ty</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">new_points</span> <span class="o">=</span> <span class="n">RW2courtIMG</span><span class="p">(</span><span class="n">world_points</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">t_vector</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x_p</span><span class="p">,</span> <span class="n">y_p</span><span class="p">,</span> <span class="n">z_p</span><span class="p">)</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">new_points</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">onClick</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>

            <span class="k">nonlocal</span> <span class="n">point_counter</span>

            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">button</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">event</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">ydata</span><span class="p">])</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">xdata</span> <span class="ow">and</span> <span class="n">event</span><span class="o">.</span><span class="n">ydata</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">point_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coordinates: </span><span class="si">{</span><span class="n">event</span><span class="o">.</span><span class="n">xdata</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">event</span><span class="o">.</span><span class="n">ydata</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">onKey</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">SKIP_CAL</span><span class="p">,</span> <span class="n">TERM_ACQ</span><span class="p">,</span> <span class="n">POP</span>

            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot; &quot;</span><span class="p">:</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipped point (space-bar keystroke detected)&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">coords</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;coords list is empty, cannot remove point&quot;</span><span class="p">)</span>

                    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coords</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Removed last point (&quot;r&quot; keystroke detected)&#39;</span><span class="p">)</span>
                    <span class="n">POP</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Point acquisition terminated by user  (&quot;t&quot; keystroke detected)&#39;</span><span class="p">)</span>
                <span class="n">TERM_ACQ</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Skipped calibration of the camera (&quot;n&quot; keystroke detected)&#39;</span><span class="p">)</span>
                <span class="n">SKIP_CAL</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span>
            <span class="s1">&#39;Press &quot;n&quot; to skip entirely the calibration of &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;this camera, (e.g. if you cannot acquire &gt;= </span><span class="si">{</span><span class="n">conf</span><span class="o">.</span><span class="n">MIN_POINTS</span><span class="si">}</span><span class="s2"> corresponding point, occlusions, ...&quot;</span><span class="p">,</span>
            <span class="s2">&quot;green&quot;</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;bold&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">pnt</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">pnt</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>

            <span class="n">POP</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">SKIP_CAL</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">TERM_ACQ</span><span class="p">:</span>

                    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
                        <span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;#2e2e2e&quot;</span>
                    <span class="p">)</span>
                    <span class="n">cid</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s2">&quot;button_press_event&quot;</span><span class="p">,</span> <span class="n">onClick</span><span class="p">)</span>
                    <span class="n">cid_key</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s2">&quot;key_press_event&quot;</span><span class="p">,</span> <span class="n">onKey</span><span class="p">)</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">courtplan</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="n">x_p</span><span class="p">[</span><span class="n">pnt</span><span class="p">],</span>
                        <span class="n">y_p</span><span class="p">[</span><span class="n">pnt</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;z= </span><span class="si">{</span><span class="n">z_p</span><span class="p">[</span><span class="n">pnt</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;x-small&quot;</span><span class="p">)</span>

                    <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">undst</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Get correspondences for camera #</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;On the right image, find on the point corresponding to the one highlighted in the court plan,&quot;</span>
                        <span class="s2">&quot; you can use the GUI tools, e.g. the zoom, to help yourself. Right click the point&quot;</span>
                        <span class="s2">&quot; to add the coordinates or press the space-bar to skip point acquisition if it is not visible.</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s1">&#39;Press &quot;n&quot; to skip camera. Press &quot;t&quot; to terminate point acquisition and go to next camera (&gt;=</span><span class="si">{</span><span class="n">conf</span><span class="o">.</span><span class="n">MIN_POINTS</span><span class="si">}</span><span class="s1"> points are needed!)</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s2">&quot;Acquired Points: </span><span class="si">{</span><span class="n">point_counter</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">box</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;round,pad=1&quot;</span><span class="p">,</span>
                        <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;royalblue&quot;</span><span class="p">,</span>
                        <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;lightsteelblue&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">txt</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                        <span class="mf">0.5</span><span class="p">,</span>
                        <span class="mf">0.78</span><span class="p">,</span>
                        <span class="n">text</span><span class="p">,</span>
                        <span class="n">family</span><span class="o">=</span><span class="s2">&quot;sans-serif&quot;</span><span class="p">,</span>
                        <span class="n">style</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span>
                        <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
                        <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">linespacing</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
                        <span class="n">bbox</span><span class="o">=</span><span class="n">box</span><span class="p">,</span>
                        <span class="n">in_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">fig_w</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">get_figwidth</span><span class="p">()</span> <span class="o">*</span> <span class="n">fig</span><span class="o">.</span><span class="n">dpi</span>
                    <span class="n">txt</span><span class="o">.</span><span class="n">_get_wrap_line_width</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">fig_w</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Point on the court plan&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">)</span>
                    <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Undistorted camera view </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span>
                    <span class="p">)</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
                    <span class="n">ax2</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">rect</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">))</span>
                    <span class="c1"># fig.legend()</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="c1"># repeat point acquisition if last acquisition is removed</span>
                <span class="k">elif</span> <span class="n">TERM_ACQ</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="n">POP</span><span class="p">:</span>
                    <span class="n">pnt</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">coords</span><span class="p">:</span>
                        <span class="n">pnt</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pnt</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">elif</span> <span class="n">SKIP_CAL</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Replace None with np.nan</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">coords</span></div>


<div class="viewcode-block" id="Camera.AddManualCorrespondences">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.AddManualCorrespondences">[docs]</a>
    <span class="k">def</span> <span class="nf">AddManualCorrespondences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_points</span><span class="p">,</span> <span class="n">image_points</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manually add corresponding points to camera attributes after performing type and NaN checks.</span>

<span class="sd">        :param world_points: Point coordinates (x, y, z) expressed in a numpy array with shape (n, 3),</span>
<span class="sd">                             where `n` is the number of points. Example: `[[x, y, z], ...]`</span>
<span class="sd">        :type world_points: numpy.ndarray</span>

<span class="sd">        :param image_points: Point coordinates (u, v) expressed in a numpy array with shape (n, 2),</span>
<span class="sd">                             where `n` is the number of points. Example: `[[u, v], ...]`</span>
<span class="sd">        :type image_points: numpy.ndarray</span>

<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: None</span>

<span class="sd">        :notes:</span>
<span class="sd">            - This method verifies that both input arrays are of type `numpy.ndarray`.</span>
<span class="sd">            - The input arrays are checked to have the correct shapes: `(n, 3)` for `world_points` and `(n, 2)` for `image_points`.</span>
<span class="sd">            - NaN values within the input arrays are filtered out before the points are stored.</span>
<span class="sd">            - If any of these checks fail, appropriate error messages will be printed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if inputs are numpy arrays</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">image_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Both world_points and image_points must be numpy arrays.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">world_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid input: world_points must have shape (n, 3).&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid input: image_points must have shape (n, 2).&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">world_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;arrays should contains the same number of points, world points: </span><span class="si">{</span><span class="n">image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, image points: </span><span class="si">{</span><span class="n">world_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Filter outs eventual NaN</span>
        <span class="n">valid_indices</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">world_points</span><span class="p">,</span> <span class="n">image_points</span><span class="p">)))</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corr_world_points</span> <span class="o">=</span> <span class="n">world_points</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_image_points</span> <span class="o">=</span> <span class="n">image_points</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="Camera.ExtCalibration">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.ExtCalibration">[docs]</a>
    <span class="k">def</span> <span class="nf">ExtCalibration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform external camera calibration to compute the transformation matrices between the world and camera coordinates.</span>

<span class="sd">        This method calculates the rotation and translation vectors using the `cv2.solvePnP` function, which solves the Perspective-n-Point problem to find the position and orientation of the camera relative to the world coordinate system. It then computes the world-to-camera and camera-to-world transformation matrices and stores them as instance attributes. Additionally, it computes the homography matrix for the plane to plane mapping of the court plane to the image plane.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        None</span>

<span class="sd">        Raises:</span>
<span class="sd">        -------</span>
<span class="sd">        SystemExit</span>
<span class="sd">            If the PnP solving process fails, an error message is printed, and the program exits.</span>

<span class="sd">        Notes:</span>
<span class="sd">        ------</span>
<span class="sd">        - The method sets the following instance attributes:</span>
<span class="sd">            - `self.W2C_mtx` : numpy.ndarray</span>
<span class="sd">                4x4 transformation matrix from world coordinates to camera coordinates.</span>
<span class="sd">            - `self.C2W_mtx` : numpy.ndarray</span>
<span class="sd">                4x4 transformation matrix from camera coordinates to world coordinates.</span>
<span class="sd">            - `self.EXT_CAL` : bool</span>
<span class="sd">                Flag indicating that the external calibration has been successfully completed.</span>
<span class="sd">            - `self.H_mtx` : numpy.ndarray</span>
<span class="sd">                Homography matrix for the court plane to the image plane.</span>

<span class="sd">        - This method relies on the instance attributes:</span>
<span class="sd">            - `self.corr_world_points` : list of tuples</span>
<span class="sd">                List of corresponding points in the world coordinates.</span>
<span class="sd">            - `self.corr_image_points` : list of tuples</span>
<span class="sd">                List of corresponding points in the image coordinates.</span>
<span class="sd">            - `self.new_mtx` : numpy.ndarray</span>
<span class="sd">                Camera matrix after undistorsion.</span>
<span class="sd">            - `self.dist` : numpy.ndarray</span>
<span class="sd">                Distortion coefficients.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">success</span><span class="p">,</span> <span class="n">rotation_vector</span><span class="p">,</span> <span class="n">translation_vector</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">solvePnP</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_world_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_image_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="s2">&quot;Error, could not solve PnP&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Exiting...&quot;</span><span class="p">)</span>
        <span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">rotation_vector</span><span class="p">)</span>

        <span class="c1"># Inverting the rotation and translation to get camera2 world transformation (used to estimate camera position)</span>

        <span class="n">w2c_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">translation_vector</span><span class="p">))</span>
        <span class="n">w2c_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">w2c_mtx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W2C_mtx</span> <span class="o">=</span> <span class="n">w2c_mtx</span>

        <span class="c1"># Get cam to world transformation</span>
        <span class="n">inverse_rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">)</span>
        <span class="n">inverse_translation_vector</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="n">inverse_rotation_matrix</span><span class="p">,</span> <span class="n">translation_vector</span>
        <span class="p">)</span>

        <span class="n">c2w_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">inverse_rotation_matrix</span><span class="p">,</span> <span class="n">inverse_translation_vector</span><span class="p">))</span>
        <span class="n">c2w_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">c2w_mtx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C2W_mtx</span> <span class="o">=</span> <span class="n">c2w_mtx</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">EXT_CAL</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Computing Homography matrix for the court plane and the image plane</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FindHomography</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_mtx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Homography matrix calculation failed!&quot;</span><span class="p">)</span>

        <span class="k">return</span></div>


<div class="viewcode-block" id="Camera.PosError">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.PosError">[docs]</a>
    <span class="k">def</span> <span class="nf">PosError</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and display the positional error between the approximate and estimated positions.</span>

<span class="sd">        This method computes the Euclidean distance between the approximate_position` and the position derived from the `C2W_mtx` matrix. The result is printed and stored in the instance variable `self.pos_err`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - `self.approximate_position` should be a list or array-like structure containing the</span>
<span class="sd">          approximate position coordinates (x, y, z).</span>
<span class="sd">        - `self.C2W_mtx` should be a 4x4 matrix where the last column represents the estimated</span>
<span class="sd">          position in 3D space.</span>
<span class="sd">        - The Euclidean distance is calculated as the norm of the difference between the</span>
<span class="sd">          approximate and estimated positions.</span>
<span class="sd">        - The result is printed in meters with three decimal places.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">actual_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">approximate_position</span><span class="p">)</span>
        <span class="n">estimated_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C2W_mtx</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

        <span class="n">euc_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">estimated_pos</span> <span class="o">-</span> <span class="n">actual_pos</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The euclidean distance error is: </span><span class="si">{</span><span class="n">euc_dist</span><span class="si">:</span><span class="s2">06.3f</span><span class="si">}</span><span class="s2"> m&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_err</span> <span class="o">=</span> <span class="n">euc_dist</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Camera.SaveErrors">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.SaveErrors">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">SaveErrors</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">camera_list</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the positional and re-projection errors of a list of cameras to a CSV file.</span>

<span class="sd">        This class method generates a CSV file containing error data for each </span>
<span class="sd">        camera in the provided list. The file is saved at the specified `path` </span>
<span class="sd">        and includes the following columns:</span>

<span class="sd">        - `CAM`: Camera identifier or number.</span>
<span class="sd">        - `x, y, z`: Approximate position coordinates of the camera.</span>
<span class="sd">        - `est. x, est. y, est. z`: Estimated position coordinates from the camera&#39;s</span>
<span class="sd">          `C2W_mtx` matrix.</span>
<span class="sd">        - `distance`: Euclidean distance between the approximate and estimated positions.</span>
<span class="sd">        - `re-projection error`: Error value representing the difference between the actual</span>
<span class="sd">          and projected positions, resulting from the intrinsic calibration procedure.</span>

<span class="sd">        The CSV file is formatted with headers and includes error values formatted to two</span>
<span class="sd">        decimal places for positions and distances, and three decimal places for re-projection</span>
<span class="sd">        errors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        camera_list : list</span>
<span class="sd">            A list of camera objects, where each object should have the following attributes:</span>
<span class="sd">            - `approximate_position` (list or array-like): The known approximate position of</span>
<span class="sd">              the camera (x, y, z).</span>
<span class="sd">            - `C2W_mtx` (numpy.ndarray): A 4x4 matrix containing the estimated position in</span>
<span class="sd">              the last column.</span>
<span class="sd">            - `camera_number` (int or str): An identifier for the camera.</span>
<span class="sd">            - `pos_err` (float): The positional error of the camera.</span>
<span class="sd">            - `rep_err` (float): The re-projection error of the camera.</span>

<span class="sd">        path : str</span>
<span class="sd">            The directory path where the CSV file should be saved.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method assumes that each camera object in `camera_list` has the required attributes.</span>
<span class="sd">        - The CSV file will be created with the name &quot;Errors.csv&quot; in the specified directory.</span>
<span class="sd">        - Ensure that the `path` provided is a valid directory path.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">camera_list</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;CAM,x,y,z,est. x,est. y,est. z, distance, re-projection error&quot;</span>
        <span class="c1"># units = &quot;,m,m,m,m,m,m,m,a.u.&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s2">&quot;/Errors.csv&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># file.write(units + &quot;\n&quot;)</span>

            <span class="k">for</span> <span class="n">cam</span> <span class="ow">in</span> <span class="n">camera_list</span><span class="p">:</span>
                <span class="n">act</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cam</span><span class="o">.</span><span class="n">approximate_position</span><span class="p">))</span>
                <span class="n">est</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cam</span><span class="o">.</span><span class="n">C2W_mtx</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

                <span class="n">line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cam</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">act</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">est</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">cam</span><span class="o">.</span><span class="n">pos_err</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">cam</span><span class="o">.</span><span class="n">rep_err</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Errors saved to file.&quot;</span><span class="p">)</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Camera.PlotCamera">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.PlotCamera">[docs]</a>
    <span class="k">def</span> <span class="nf">PlotCamera</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the camera&#39;s position and direction on a 3D axis.</span>

<span class="sd">        This method visualizes the camera&#39;s approximate position and estimated position</span>
<span class="sd">        on a 3D plot. It also displays a line indicating the camera&#39;s direction vector and</span>
<span class="sd">        a dashed line connecting the approximate and estimated positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib.axes._axes.Axes</span>
<span class="sd">            The 3D axis object on which to plot the camera information.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is intended to bella called by the PlotMultipleCameras() class method.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        PlotMultipleCameras() : Class Method to plot multiple cameras on 3D scheme of the court.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">act_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">approximate_position</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">act_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">act_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">act_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>

        <span class="n">cam_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C2W_mtx</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="n">cam_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">cam_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">cam_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;CAM</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2"> [Err: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_err</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> m]&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># direction vector size</span>
        <span class="n">cam_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C2W_mtx</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vec</span><span class="p">])</span> <span class="o">+</span> <span class="n">cam_pos</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="p">[</span><span class="n">cam_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cam_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">cam_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cam_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">cam_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cam_dir</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkgray&quot;</span><span class="p">,</span>
            <span class="c1"># label=f&quot;CAM{self.camera_number} Direction&quot;,</span>
        <span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">act_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cam_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">act_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cam_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">act_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cam_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="s2">&quot;r--&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="k">return</span></div>


<div class="viewcode-block" id="Camera.PlotCamera2D">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.PlotCamera2D">[docs]</a>
    <span class="k">def</span> <span class="nf">PlotCamera2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the camera&#39;s position and direction on a 2D axis over a court image.</span>

<span class="sd">        This method visualizes the camera&#39;s estimated and approximate positions on a 2D plot</span>
<span class="sd">        with an overlay of a court image. It also shows the direction of the camera with a line</span>
<span class="sd">        and connects the estimated and approximate positions with a dashed line.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib.axes._axes.Axes</span>
<span class="sd">            The 2D axis object on which to plot the camera information.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - *This method is intended to bella called by the PlotMultipleCameras2D() class method.*</span>
<span class="sd">        - The court image is loaded from the path specified by `conf.COURT_IMG_XL`.</span>
<span class="sd">        - The camera&#39;s estimated position is plotted as a circular marker, while the</span>
<span class="sd">          approximate position is plotted as a gray downward-pointing triangle marker.</span>
<span class="sd">        - A dashed red line connects the estimated position to the approximate position to</span>
<span class="sd">          indicate positional error.</span>
<span class="sd">        - The camera&#39;s direction is shown as a line extending from the estimated position</span>
<span class="sd">          in the direction of the camera&#39;s field of view.</span>
<span class="sd">        - An annotation with the camera number is placed near the approximate position,</span>
<span class="sd">          with a text path effect for better visibility.</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        PlotMultipleCameras2D() : Class Method to plot multiple cameras on 2D scheme of the court.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cam_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C2W_mtx</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">approx_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">approximate_position</span>
        <span class="n">court_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">COURT_IMG_XL</span><span class="p">)</span>

        <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">court_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ty</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">201</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">RW2courtIMG</span><span class="p">(</span><span class="n">cam_pos</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">t_vector</span><span class="p">)</span>
        <span class="n">app_pos</span> <span class="o">=</span> <span class="n">RW2courtIMG</span><span class="p">(</span><span class="n">approx_pos</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">t_vector</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;CAM</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">; z:</span><span class="si">{</span><span class="n">cam_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> (m)&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="n">app_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">app_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span>
        <span class="p">)</span>  <span class="c1"># ,label=f&quot;CAM{self.camera_number} from measurement&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">app_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">app_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;r--&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">text</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;CAM </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="c1"># # z = {position[3]}</span>
            <span class="c1"># f&quot;\n Error {self.pos_err:.2f} m&quot;,</span>
            <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">app_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">app_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
            <span class="c1"># arrowprops=dict(facecolor=&quot;lightgray&quot;, arrowstyle=&quot;-&gt;&quot;),</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">text</span><span class="o">.</span><span class="n">set_path_effects</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">path_effects</span><span class="o">.</span><span class="n">Stroke</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">foreground</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">),</span>
                <span class="n">path_effects</span><span class="o">.</span><span class="n">Normal</span><span class="p">(),</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">vec</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># direction vector size</span>
        <span class="n">cam_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C2W_mtx</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vec</span><span class="p">])</span> <span class="o">+</span> <span class="n">cam_pos</span>

        <span class="n">new_cam_dir</span> <span class="o">=</span> <span class="n">RW2courtIMG</span><span class="p">(</span><span class="n">cam_dir</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">t_vector</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="p">[</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_cam_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_cam_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkgray&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Camera.PlotMultipleCameras">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.PlotMultipleCameras">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">PlotMultipleCameras</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">camera_list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the positions and orientations of multiple cameras on a 3D plot.</span>

<span class="sd">        This class method visualizes all cameras in the provided list on a 3D axis. It</span>
<span class="sd">        includes the following features:</span>

<span class="sd">        - Plots each camera&#39;s approximate and estimated positions.</span>
<span class="sd">        - Draws direction vectors for each camera.</span>
<span class="sd">        - Optionally overlays a court image or displays predefined court points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        camera_list : list</span>
<span class="sd">            A list of camera objects, where each object should have the following methods</span>
<span class="sd">            and attributes:</span>
<span class="sd">            - `PlotCamera(ax)`: Method to plot a single camera on the 3D axis.</span>
<span class="sd">            - `approximate_position` (list or array-like): The known approximate position</span>
<span class="sd">              of the camera (x, y, z).</span>
<span class="sd">            - `C2W_mtx` (numpy.ndarray): A 4x4 matrix containing the estimated position</span>
<span class="sd">              in the last column.</span>
<span class="sd">            - `camera_number` (int or str): An identifier for the camera.</span>
<span class="sd">            - `pos_err` (float): The positional error of the camera.</span>
<span class="sd">            - `rep_err` (float): The re-projection error of the camera.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.figure.Figure</span>
<span class="sd">        The figure object containing the 2D plot with camera positions.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method creates a 3D plot with camera positions, direction vectors, and</span>
<span class="sd">          optional court details.</span>
<span class="sd">        - Court image is plotted if `conf.SHOW_COURT` is `True`, otherwise, predefined</span>
<span class="sd">          court points are displayed.</span>
<span class="sd">        - The plot&#39;s axes are labeled and ticked to provide clear context for the camera</span>
<span class="sd">          positions.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To plot multiple cameras:</span>
<span class="sd">        ::</span>
<span class="sd">            fig = CameraUtils.Camera.PlotMultipleCameras(camera_list)</span>
<span class="sd">        </span>
<span class="sd">        where `Camera` is the class containing this method, and `camera_list` is a list</span>
<span class="sd">        of camera objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">camera</span> <span class="ow">in</span> <span class="n">camera_list</span><span class="p">:</span>
            <span class="n">camera</span><span class="o">.</span><span class="n">PlotCamera</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">COURT_IMG_LR</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span>

        <span class="c1"># ax.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span>

        <span class="n">xlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">16.0</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">9.5</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">x_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">x_img</span><span class="p">,</span> <span class="n">y_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_img</span><span class="p">,</span> <span class="n">y_img</span><span class="p">)</span>
        <span class="n">z_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x_img</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">SHOW_COURT</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span>
                <span class="o">-</span><span class="n">x_img</span><span class="p">,</span>
                <span class="o">-</span><span class="n">y_img</span><span class="p">,</span>
                <span class="n">z_img</span><span class="p">,</span>
                <span class="n">rstride</span><span class="o">=</span><span class="n">conf</span><span class="o">.</span><span class="n">COURT_IMG_QUALITY</span><span class="p">,</span>
                <span class="n">cstride</span><span class="o">=</span><span class="n">conf</span><span class="o">.</span><span class="n">COURT_IMG_QUALITY</span><span class="p">,</span>
                <span class="n">facecolors</span><span class="o">=</span><span class="n">img</span><span class="p">,</span>
                <span class="n">shade</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">x_p</span><span class="p">,</span>
                <span class="n">y_p</span><span class="p">,</span>
                <span class="n">z_p</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">conf</span><span class="o">.</span><span class="n">COURT_POINTS</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_p</span><span class="p">,</span> <span class="n">y_p</span><span class="p">,</span> <span class="n">z_p</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_box_aspect</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;x (m)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;y (m)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s2">&quot;z (m)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Camera positions with respect to the court&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower left&quot;</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;x-small&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="Camera.PlotMultipleCameras2D">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.PlotMultipleCameras2D">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">PlotMultipleCameras2D</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">camera_list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the positions of multiple cameras on a 2D court image.</span>

<span class="sd">        This class method creates a 2D plot showing the positions of all cameras in the</span>
<span class="sd">        provided list overlaid on a court image. Each camera&#39;s position is plotted, and</span>
<span class="sd">        their respective direction vectors are displayed. The court image serves as a</span>
<span class="sd">        reference for the positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        camera_list : list</span>
<span class="sd">            A list of camera objects, where each object should have the `PlotCamera2D(ax)` method to plot its position on the 2D axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.figure.Figure</span>
<span class="sd">            The figure object containing the 2D plot with camera positions.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The court image is loaded from the path specified by `conf.COURT_IMG_XL`.</span>
<span class="sd">        - The x and y coordinates are adjusted to match the dimensions of the image.</span>
<span class="sd">        - Each camera is plotted using the `PlotCamera2D` method, which should be defined in the same class as this method.</span>
<span class="sd">        - The axis labels are set to &quot;x&quot; and &quot;y&quot; to indicate the coordinate axes.</span>
<span class="sd">        - The image axis is turned off for a cleaner display of camera positions.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To plot multiple cameras on a 2D image:</span>
<span class="sd">        ::</span>
<span class="sd">            fig = CameraClass.PlotMultipleCameras2D(camera_list)</span>
<span class="sd">        where `CameraClass` is the class containing this method, and `camera_list` is a list of camera objects.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        PlotCamera2D : Method used to plot individual camera positions on a 2D axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">()</span>

        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">COURT_IMG_XL</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
        <span class="n">yl</span><span class="p">,</span> <span class="n">xl</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">camera</span> <span class="ow">in</span> <span class="n">camera_list</span><span class="p">:</span>
            <span class="n">camera</span><span class="o">.</span><span class="n">PlotCamera2D</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">yl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Camera positions with reference to the court (2D)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
        <span class="c1"># fig.tight_layout(pad = 3)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;CAMs&quot;</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower left&quot;</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;x-small&quot;</span><span class="p">)</span>
        <span class="c1"># plt.show()</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="Camera.PrintAttributes">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.PrintAttributes">[docs]</a>
    <span class="k">def</span> <span class="nf">PrintAttributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_attributes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;obj_points&quot;</span><span class="p">,</span> <span class="s2">&quot;img_points&quot;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints all the attributes of the CameraInfo instance, except for those in the skip_attributes list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skip_attributes : list of str, optional</span>
<span class="sd">            A list of attribute names to exclude from printing. Default is:</span>
<span class="sd">            [&quot;obj_points&quot;,&quot;img_points&quot;]</span>

<span class="sd">            Input skip_attributes = None to print all attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">skip_attributes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_attributes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_attributes</span><span class="p">:</span>

                <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;bold&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">PrintMtx</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">09.3f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">09.3f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">09.3f</span><span class="si">}</span><span class="s2">]&quot;</span>
                            <span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="mi">33</span> <span class="o">*</span> <span class="s2">&quot;*&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="mi">80</span> <span class="o">*</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Camera.FindHomography">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.FindHomography">[docs]</a>
    <span class="k">def</span> <span class="nf">FindHomography</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the homography matrix from world coordinates (court plane) to image coordinates.</span>

<span class="sd">        This method calculates the homography matrix using corresponding world and image</span>
<span class="sd">        points on a plane. It utilizes the RANSAC algorithm to robustly estimate the homography.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method requires at least 4 corresponding points in both the world and image</span>
<span class="sd">          coordinate systems to compute the homography matrix. If fewer than 4 points are</span>
<span class="sd">          provided, an error message is printed and the method returns `None`.</span>
<span class="sd">        - The computed homography matrix `H` is stored in the `self.H_mtx` attribute.</span>
<span class="sd">        - The RANSAC algorithm is used with a reprojection threshold of 5 and a confidence</span>
<span class="sd">          level of 0.9 to handle outliers in the point correspondences.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To compute the homography matrix, ensure that `self.corr_world_points` and</span>
<span class="sd">        `self.corr_image_points` are properly set with at least 4 corresponding points.</span>
<span class="sd">        Then call:</span>
<span class="sd">        ::</span>
<span class="sd">            self.FindHomography()</span>

<span class="sd">        where `self` is an instance of the class containing this method.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        cv2.findHomography : OpenCV function used to compute the homography matrix.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">src_pnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_world_points</span>
        <span class="n">dst_pnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_image_points</span>
        <span class="k">if</span> <span class="n">src_pnt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">dst_pnt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: At least 4 points are required to compute the homography.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findHomography</span><span class="p">(</span>
            <span class="n">srcPoints</span><span class="o">=</span><span class="n">src_pnt</span><span class="p">,</span>
            <span class="n">dstPoints</span><span class="o">=</span><span class="n">dst_pnt</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">RANSAC</span><span class="p">,</span>
            <span class="n">ransacReprojThreshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">confidence</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_mtx</span> <span class="o">=</span> <span class="n">H</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Camera.Court2Image">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.Court2Image">[docs]</a>
    <span class="k">def</span> <span class="nf">Court2Image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert court coordinates to image coordinates using the homography matrix.</span>

<span class="sd">        This method maps 2D coordinates from the court plane to 2D image coordinates</span>
<span class="sd">        using the homography matrix. It is useful for projecting points from the court</span>
<span class="sd">        space onto the image plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : numpy.ndarray</span>
<span class="sd">            A 2D numpy array of shape (n, 2) representing coordinates on the court plane in the format [x, y].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            A 2D numpy array of shape (n, 2) representing the image coordinates in the format [u, v].</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method appends a column of ones to the court coordinates to convert them to homogeneous coordinates.</span>
<span class="sd">        - The homography matrix `self.H_mtx` must be set before calling this method. If `self.H_mtx` is `None`, the method prints an error message and returns `None`.</span>
<span class="sd">        - The coordinates are transformed using the homography matrix and normalized to obtain the (u, v) coordinates on the image plane.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Image2Court : Method used to convert image coordinates to court coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid input argument, the point coordinates must be: [x,y,z]&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Exiting...&quot;</span><span class="p">)</span>

        <span class="n">ones_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">h_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">h_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">h_coords</span><span class="p">,</span> <span class="n">ones_column</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_mtx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Homography matrix is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">H_mtx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Transform coordinates to image plane</span>
        <span class="n">img_pnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">h_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_mtx</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Normalize to get (u, v) coordinates</span>
        <span class="n">uv_coords</span> <span class="o">=</span> <span class="n">img_pnts</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">img_pnts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">uv_coords</span></div>


<div class="viewcode-block" id="Camera.Image2Court">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.Camera.Image2Court">[docs]</a>
    <span class="k">def</span> <span class="nf">Image2Court</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert image coordinates to court coordinates using the homography matrix.</span>

<span class="sd">        This method transforms 2D image coordinates into coordinates on the court plane</span>
<span class="sd">        by applying the inverse of the homography matrix. It is useful for mapping points</span>
<span class="sd">        from the image space to a corresponding position on the court.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : numpy.ndarray</span>
<span class="sd">            A 2D numpy array of shape (n, 2) representing image coordinates in the format [u, v].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            A 2D numpy array of shape (n, 2) representing the coordinates on the court plane in the format [x, y].</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method appends a column of ones to the image coordinates to convert them to homogeneous coordinates.</span>
<span class="sd">        - The homography matrix `self.H_mtx` must be set before calling this method. If `self.H_mtx` is `None`, the method prints an error message and returns `None`.</span>
<span class="sd">        - The inverse of the homography matrix is used to transform the coordinates to the court plane.</span>
<span class="sd">        - The resulting coordinates are normalized to obtain the (x, y) coordinates on the court.</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        FindHomography : Method used to compute the homography matrix which is required for this conversion.</span>
<span class="sd">        Court2Image : Inverse method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Invalid input argument shape, the image coordinates&quot;</span>
                <span class="s2">&quot; must be a np.array([[u,v]])&quot;</span>
            <span class="p">)</span>
            <span class="c1"># sys.exit(1)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_mtx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Homography matrix is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">H_mtx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># Append the column of ones to 3D points</span>
        <span class="n">ones_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">coords</span><span class="p">,</span> <span class="n">ones_column</span><span class="p">))</span>

        <span class="n">Ainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_mtx</span><span class="p">)</span>

        <span class="n">court_pnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">Ainv</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">XY_coords</span> <span class="o">=</span> <span class="n">court_pnts</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">court_pnts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">XY_coords</span></div>
</div>



<span class="c1">#   ____  _       _    ____    _    __  __ _____ ____      _    ____</span>
<span class="c1">#  |  _ \| | ___ | |_ / ___|  / \  |  \/  | ____|  _ \    / \  / ___|</span>
<span class="c1">#  | |_) | |/ _ \| __| |     / _ \ | |\/| |  _| | |_) |  / _ \ \___ \</span>
<span class="c1">#  |  __/| | (_) | |_| |___ / ___ \| |  | | |___|  _ &lt;  / ___ \ ___) |</span>
<span class="c1">#  |_|   |_|\___/ \__|\____/_/   \_\_|  |_|_____|_| \_\/_/   \_\____/</span>


<div class="viewcode-block" id="PlotCameras">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PlotCameras">[docs]</a>
<span class="k">class</span> <span class="nc">PlotCameras</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the plotting of camera views around the court and manages the visualization</span>
<span class="sd">    of points on the court surface across all camera views.</span>

<span class="sd">    This class is designed to initialize camera views and axes, add new camera views,</span>
<span class="sd">    and set up a plot layout with the court plan in the center and camera views around it.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    views : dict</span>
<span class="sd">        A dictionary mapping camera identifiers (e.g., &quot;CAM1&quot;, &quot;CAM2&quot;) to instances of</span>
<span class="sd">        the `Camera` class. This holds all the camera views.</span>
<span class="sd">    axes : dict</span>
<span class="sd">        A dictionary mapping camera identifiers and &quot;court&quot; to matplotlib axes objects.</span>
<span class="sd">        These axes are used for plotting the camera views and the court plan.</span>
<span class="sd">    points : numpy.ndarray</span>
<span class="sd">        An array of shape (n, 2) to store the coordinates of points picked on the court.</span>
<span class="sd">    court_plan : numpy.ndarray</span>
<span class="sd">        An image representing the court plan, used as a background for plotting.</span>
<span class="sd">    color_counter : int</span>
<span class="sd">        A counter used to assign different colors to highlighted points.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __init__()</span>
<span class="sd">        Initializes the `PlotCameras` object with empty camera views and axes, and loads</span>
<span class="sd">        the court plan image.</span>

<span class="sd">    AddView(camera)</span>
<span class="sd">        Adds a new camera view to the `views` dictionary.</span>

<span class="sd">    InitPlot()</span>
<span class="sd">        Initializes the plot layout with the court plan in the middle and camera views</span>
<span class="sd">        around it. Configures the layout and sets up the plotting environment.</span>

<span class="sd">    PlotImages()</span>

<span class="sd">        Plots the images for all camera views on their respective axes.</span>

<span class="sd">    ShowViews()</span>
<span class="sd">        Displays the plotted views and connects mouse and keyboard event handlers.</span>

<span class="sd">    _on_click(event)</span>
<span class="sd">        </span>
<span class="sd">        Handles mouse click events to record points on the court and save them to the points attribute.</span>
<span class="sd">    </span>
<span class="sd">    _on_key(event):</span>
<span class="sd">        </span>
<span class="sd">        Handles keyboard events to clear points when &#39;c&#39; is pressed.    </span>
<span class="sd">    </span>
<span class="sd">    DrawPoints():</span>
<span class="sd">        Draws the most recently added point on the images and the court plan.</span>
<span class="sd">    </span>
<span class="sd">    ClearPoints():</span>
<span class="sd">        Clears all recorded points from the `points` attribute and removes them from the plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotCameras.__init__">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PlotCameras.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># , *args):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the PlotCameras object with camera views and axes setup.</span>

<span class="sd">        This constructor sets up the initial state of the `PlotCameras` instance:</span>
<span class="sd">        - Initializes dictionaries for camera views and axes.</span>
<span class="sd">        - Loads the court plan image from a predefined configuration path.</span>
<span class="sd">        - Initializes an empty array for storing picked points and a color counter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">views</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;CAM1&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;CAM2&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;CAM3&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;CAM4&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;CAM5&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;CAM6&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;CAM7&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;CAM8&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;CAM12&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;CAM13&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;CAM1&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc1,</span>
            <span class="s2">&quot;CAM2&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc2,</span>
            <span class="s2">&quot;CAM3&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc3,</span>
            <span class="s2">&quot;CAM4&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc4,</span>
            <span class="s2">&quot;CAM5&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc5,</span>
            <span class="s2">&quot;CAM6&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc6,</span>
            <span class="s2">&quot;CAM7&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc7,</span>
            <span class="s2">&quot;CAM8&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc8,</span>
            <span class="s2">&quot;CAM12&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc12,</span>
            <span class="s2">&quot;CAM13&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axc13,</span>
            <span class="s2">&quot;court&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># axcourt,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">court_plan</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">COURT_IMG_MR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_counter</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="PlotCameras.AddView">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PlotCameras.AddView">[docs]</a>
    <span class="k">def</span> <span class="nf">AddView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">camera</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a camera view to the `views` dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        camera : Camera</span>
<span class="sd">            An instance of the `Camera` class that will be added to the `views` dictionary.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `camera` parameter should be an instance of the `Camera` class with a</span>
<span class="sd">        `camera_number` attribute that corresponds to the camera identifier (e.g., &quot;CAM1&quot;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cam_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;CAM</span><span class="si">{</span><span class="n">camera</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">views</span><span class="p">[</span><span class="n">cam_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">camera</span></div>


<div class="viewcode-block" id="PlotCameras.InitPlot">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PlotCameras.InitPlot">[docs]</a>
    <span class="k">def</span> <span class="nf">InitPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the plot layout with a court plan in the middle and camera views around it.</span>

<span class="sd">        This method sets up a matplotlib figure with a grid layout, placing the court plan image in the center and arranging the camera views around it. It also configures the axes for the court plan and each camera view, and sets a figure-wide title with instructions for interacting with the plot.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The layout consists of a 4x3 grid, with camera views placed in locations reflecting their real distribution around the court, which is displayed in the central subplot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">col</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span>
            <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">layout</span><span class="o">=</span><span class="s2">&quot;constrained&quot;</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;#2e2e2e&quot;</span>
        <span class="p">)</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_gridspec</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">row</span><span class="p">)</span>

        <span class="c1"># Placing camera views according to the real world placement</span>
        <span class="c1"># with reference to the court</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM4&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM5&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM6&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM7&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM8&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM12&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;CAM13&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Court axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;court&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Plot the court plan in the middle of the figure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;court&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">court_plan</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;court&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
        <span class="c1"># Plot suptitle and text</span>
        <span class="c1">#  self.fig.tight_layout()#rect=[0, 0.05, 1, 0.95])</span>
        <span class="n">text</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Right-click a point on the court to highlight it in all camera views,&quot;</span>
            <span class="s2">&quot; you can use the GUI tools, e.g. the zoom, to help yourself.&quot;</span>
            <span class="s1">&#39;Press &quot;c&quot; to clear the highlighted points, &quot;q&quot; to quit.&#39;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PlotCameras.PlotImages">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PlotCameras.PlotImages">[docs]</a>
    <span class="k">def</span> <span class="nf">PlotImages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the images for all camera views on their respective axes.</span>

<span class="sd">        This method reads images from the specified paths, undistorts them based on calibration parameters, resizes the images to improve plot rendering performance, and then displays them on their respective axes in the matplotlib figure. Each camera view is annotated with its identifier.</span>

<span class="sd">        The images are rescaled by a factor defined in `conf.SCALE` to enhance plotting performance. Camera identifiers are added as text annotations on the images.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">cam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">views</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;court&quot;</span><span class="p">:</span>
                <span class="c1"># read image</span>
                <span class="n">image_path</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">SAMPLE_PATH</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Cam</span><span class="si">{</span><span class="n">cam</span><span class="o">.</span><span class="n">camera_number</span><span class="si">}</span><span class="s2">.jpg&quot;</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span>
                <span class="c1"># undistort the image</span>
                <span class="k">if</span> <span class="n">cam</span><span class="o">.</span><span class="n">FISHEYE</span><span class="p">:</span>
                    <span class="n">undst</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fisheye</span><span class="o">.</span><span class="n">undistortImage</span><span class="p">(</span>
                        <span class="n">image</span><span class="p">,</span> <span class="n">cam</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="n">cam</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="n">Knew</span><span class="o">=</span><span class="n">cam</span><span class="o">.</span><span class="n">new_mtx</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">undst</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">undistort</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cam</span><span class="o">.</span><span class="n">mtx</span><span class="p">,</span> <span class="n">cam</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cam</span><span class="o">.</span><span class="n">new_mtx</span><span class="p">)</span>

                <span class="c1"># Rescale image with conf.SCALE factor to reduce the of the plot,</span>
                <span class="c1">#  so it is (hopefully) faster to render</span>
                <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">dim</span> <span class="o">*</span> <span class="n">conf</span><span class="o">.</span><span class="n">SCALE</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">undst</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]</span>
                <span class="n">resized</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">undst</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_AREA</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">resized</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>

                <span class="c1"># Adding Camera Tag</span>
                <span class="n">box</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;square,pad=0.2&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;steelblue&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                    <span class="mi">20</span><span class="p">,</span>
                    <span class="mi">40</span><span class="p">,</span>
                    <span class="n">key</span><span class="p">,</span>
                    <span class="n">family</span><span class="o">=</span><span class="s2">&quot;sans-serif&quot;</span><span class="p">,</span>
                    <span class="n">style</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span>
                    <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                    <span class="n">bbox</span><span class="o">=</span><span class="n">box</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PlotCameras.ShowViews">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PlotCameras.ShowViews">[docs]</a>
    <span class="k">def</span> <span class="nf">ShowViews</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Displays the plotted views and connects mouse and keyboard event handlers.</span>

<span class="sd">        This method activates the interactive GUI for highlighting points across camera views. It sets up event handlers for mouse clicks and keyboard presses, allowing users to interact with the plot, highlight points, and clear them using specific key commands. The GUI is displayed using `plt.show()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cid_button</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s2">&quot;button_press_event&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_click</span><span class="p">)</span>
        <span class="n">cid_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s2">&quot;key_press_event&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_key</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Showing the point highlight GUI&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="PlotCameras._on_click">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PlotCameras._on_click">[docs]</a>
    <span class="k">def</span> <span class="nf">_on_click</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles mouse click events to record points on the court and save them to the points attribute.</span>

<span class="sd">         This method is for internal use only and is called when a mouse click event occurs within the matplotlib figure. It processes right-clicks to determine if a point is being selected on the court or in one of the camera views. The coordinates of the clicked point are converted and stored in the `points` attribute. It also triggers the drawing of the selected points on the plot.</span>

<span class="sd">         Parameters</span>
<span class="sd">         ----------</span>
<span class="sd">         event : matplotlib.backend_bases.MouseEvent</span>
<span class="sd">             The mouse click event, which includes coordinates and the axis where the click occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">inaxes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">button</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">event</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">ydata</span><span class="p">]])</span>
                <span class="n">clicked_axis</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">inaxes</span>
                <span class="n">clicked_axis_key</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="n">clicked_axis</span><span class="p">:</span>
                        <span class="n">clicked_axis_key</span> <span class="o">=</span> <span class="n">key</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;court&quot;</span><span class="p">:</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">views</span><span class="p">[</span><span class="n">clicked_axis_key</span><span class="p">]</span><span class="o">.</span><span class="n">Image2Court</span><span class="p">(</span><span class="n">u</span> <span class="o">/</span> <span class="n">conf</span><span class="o">.</span><span class="n">SCALE</span><span class="p">),</span>
                        <span class="p">),</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">DrawPoints</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;court&quot;</span><span class="p">:</span>

                    <span class="n">uh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">pnt</span> <span class="o">=</span> <span class="n">courtIMG2RW</span><span class="p">(</span><span class="n">uh</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">399</span><span class="p">,</span> <span class="mi">237</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">pnt</span><span class="p">),</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">DrawPoints</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_on_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles keyboard events to clear points when &#39;c&#39; is pressed.</span>

<span class="sd">        This method is for internal use only and is called when a keyboard event occurs. It listens for the &#39;c&#39; key press and clears all recorded points from the plot and the `points` attribute. This method is intended for internal use within the GUI interaction logic.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        event : matplotlib.backend_bases.KeyEvent</span>
<span class="sd">            The keyboard event, which includes the key that was pressed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ClearPoints</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cleared Stored Points (&quot;c&quot; keystroke detected)&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="PlotCameras.DrawPoints">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PlotCameras.DrawPoints">[docs]</a>
    <span class="k">def</span> <span class="nf">DrawPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draws the most recently added point on the images and the court plan.</span>

<span class="sd">        This method plots the last added point on all camera views and the court plan.</span>
<span class="sd">        It projects the point from court coordinates to image coordinates for camera views, and to the court plan for visualization. Points outside the view or court plan are excluded. The color of the points is determined by `color_counter`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method updates the plot for each camera view and the court plan, and then increments the `color_counter` for distinguishing multiple points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if there are any points to draw</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># No points to draw</span>

        <span class="c1"># Get the last added point</span>
        <span class="n">last_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># loop through axes</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;court&quot;</span><span class="p">:</span>
                <span class="c1"># read the point and project it to the image plane</span>
                <span class="n">Point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">views</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">Court2Image</span><span class="p">(</span><span class="n">last_point</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">Point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># mask out point that lies outside the image</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">Point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                        <span class="ow">and</span> <span class="n">Point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">views</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">roi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="ow">and</span> <span class="n">Point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                        <span class="ow">and</span> <span class="n">Point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">views</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">roi</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="c1"># scale the point according to the scale factor</span>
                        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">conf</span><span class="o">.</span><span class="n">SCALE</span>
                        <span class="c1"># Plot only the last point</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">u</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">v</span><span class="p">],</span>
                            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">color_counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
                            <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;court&quot;</span><span class="p">:</span>
                <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">court_plan</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">RF_origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="c1"># Get translation vector form RW to Img transformation</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">last_point</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">point</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]]))</span>  <span class="c1"># Add a zero for the z-coordinate</span>
                <span class="n">new_point</span> <span class="o">=</span> <span class="n">RW2courtIMG</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">RF_origin</span><span class="p">)</span>

                <span class="c1"># mask out point that lies outside the court plan</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">new_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span>
                    <span class="ow">and</span> <span class="n">new_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">new_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">h</span>
                <span class="p">):</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">new_point</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="c1"># Plot only the last point</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">x</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">y</span><span class="p">],</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">color_counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
                        <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>


<div class="viewcode-block" id="PlotCameras.ClearPoints">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PlotCameras.ClearPoints">[docs]</a>
    <span class="k">def</span> <span class="nf">ClearPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears all recorded points from the `points` attribute and removes them from the plot.</span>

<span class="sd">        This method resets the `points` attribute to an empty array and iterates through all axes to remove plotted points. The figure is then updated to reflect the cleared points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">artist</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">artist</span><span class="p">,</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">PathCollection</span><span class="p">):</span>
                    <span class="n">artist</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>
</div>



<span class="c1">#    ___  _   _                 _____                 _   _</span>
<span class="c1">#   / _ \| |_| |__   ___ _ __  |  ___|   _ _ __   ___| |_(_) ___  _ __  ___</span>
<span class="c1">#  | | | | __| &#39;_ \ / _ \ &#39;__| | |_ | | | | &#39;_ \ / __| __| |/ _ \| &#39;_ \/ __|</span>
<span class="c1">#  | |_| | |_| | | |  __/ |    |  _|| |_| | | | | (__| |_| | (_) | | | \__ \</span>
<span class="c1">#   \___/ \__|_| |_|\___|_|    |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/</span>

<span class="c1"># Function for random file sampling</span>
<div class="viewcode-block" id="SampleFile">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.SampleFile">[docs]</a>
<span class="k">def</span> <span class="nf">SampleFile</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly selects a file from a specified folder.</span>

<span class="sd">    This function scans the provided folder for files and randomly selects one from the list of files found. If no files are found, a warning message is printed.</span>

<span class="sd">    :param folder: The path to the folder to scan for files.</span>
<span class="sd">    :type folder: str</span>
<span class="sd">    :return: The path of the randomly selected file.</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    :raises FileNotFoundError: If the folder does not contain any files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="k">as</span> <span class="n">entries</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
                <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">termcolor</span><span class="o">.</span><span class="n">cprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No files found in this folder: </span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">)</span>

    <span class="c1"># Randomly select one file from the list of files</span>
    <span class="n">sampled_file</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sampled_file</span></div>



<div class="viewcode-block" id="GetFrame">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.GetFrame">[docs]</a>
<span class="k">def</span> <span class="nf">GetFrame</span><span class="p">(</span><span class="n">video_folder</span><span class="p">,</span> <span class="n">cam_number</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts and saves a specific frame from a video file.</span>

<span class="sd">    This function reads the specified frame from a video file associated with a given camera number and saves it as an image file. If the video file cannot be opened or the frame cannot be read, an error message is printed.</span>

<span class="sd">    :param video_folder: The folder where the video files are located.</span>
<span class="sd">    :type video_folder: str</span>
<span class="sd">    :param cam_number: The camera number to identify the video file.</span>
<span class="sd">    :type cam_number: int</span>
<span class="sd">    :param n: The frame number to extract from the video.</span>
<span class="sd">    :type n: int</span>
<span class="sd">    :return: None</span>
<span class="sd">    :rtype: None</span>
<span class="sd">    :raises ValueError: If the video file cannot be opened or the frame cannot be read.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">video_folder</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/out</span><span class="si">{</span><span class="n">cam_number</span><span class="si">}</span><span class="s2">.mp4&quot;</span>

    <span class="n">cap</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cap</span><span class="o">.</span><span class="n">isOpened</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not open the video file: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">cap</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">CAP_PROP_POS_FRAMES</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">ret</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">cap</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not read frame </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cap</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="n">save_to</span> <span class="o">=</span> <span class="n">video_folder</span> <span class="o">+</span> <span class="s2">&quot;/Samples&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">save_to</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">save_to</span><span class="p">)</span>

    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">save_to</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/Cam</span><span class="si">{</span><span class="n">cam_number</span><span class="si">}</span><span class="s2">.jpg&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">-th frame of camera </span><span class="si">{</span><span class="n">cam_number</span><span class="si">}</span><span class="s2"> successfully saved&quot;</span><span class="p">)</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="PrintMtx">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.PrintMtx">[docs]</a>
<span class="k">def</span> <span class="nf">PrintMtx</span><span class="p">(</span><span class="n">mtx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print a matrix in human readable format</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">mtx</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">09.3f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">r</span><span class="p">))</span>

    <span class="k">return</span></div>



<div class="viewcode-block" id="RW2courtIMG">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.RW2courtIMG">[docs]</a>
<span class="k">def</span> <span class="nf">RW2courtIMG</span><span class="p">(</span><span class="n">RW_point</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">RF_Img</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms a point from the real-world court coordinate system to the image coordinate system</span>
<span class="sd">    for a court plan.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    RW_point : np.ndarray</span>
<span class="sd">        A 3D point in the real-world court reference frame, represented as a numpy array</span>
<span class="sd">        in homogeneous coordinates, e.g., np.array([x, y, 1]).</span>
<span class="sd">    scale : float</span>
<span class="sd">        The scale factor representing the ratio of pixels to meters.</span>
<span class="sd">        For example, a scale of 50 means 50 pixels correspond to 1 meter.</span>
<span class="sd">    RF_Img : list or tuple</span>
<span class="sd">        A list or tuple containing the (u, v) coordinates of the reference frame origin in the image,</span>
<span class="sd">        corresponding to the real-world origin (x, y) of the court.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        A 2D numpy array with the transformed (u, v) coordinates in the image plane.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function uses a transformation matrix to convert the real-world court coordinates</span>
<span class="sd">    to the image court coordinates, applying scaling and translation to the point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Go from real court RF world to image court plan</span>
    <span class="n">t_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">*</span> <span class="n">scale</span>
    <span class="n">t_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">RF_Img</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">RF_Img</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">RW_point</span><span class="p">,</span> <span class="n">t_mtx</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">new_point</span> <span class="o">+=</span> <span class="n">t_vector</span>
    <span class="k">return</span> <span class="n">new_point</span></div>



<div class="viewcode-block" id="courtIMG2RW">
<a class="viewcode-back" href="../CameraUtils.html#CameraUtils.courtIMG2RW">[docs]</a>
<span class="k">def</span> <span class="nf">courtIMG2RW</span><span class="p">(</span><span class="n">img_pnt</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">RF_Img</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms a point from the image coordinate system to the real-world court coordinate system</span>
<span class="sd">    using a homogenous transformation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img_pnt : np.ndarray</span>
<span class="sd">        A point in the image coordinate system, represented as a numpy array in homogeneous coordinates,</span>
<span class="sd">        e.g., np.array([[u, v, 1]]).</span>
<span class="sd">    scale : float</span>
<span class="sd">        The scale factor representing the ratio of pixels to meters.</span>
<span class="sd">        For example, a scale of 50 means 50 pixels correspond to 1 meter.</span>
<span class="sd">    RF_Img : list or tuple</span>
<span class="sd">        A list or tuple containing the (u, v) coordinates of the image&#39;s reference frame origin,</span>
<span class="sd">        corresponding to the real-world origin (x, y) of the court.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        A 2D numpy array representing the transformed (x, y) coordinates in the real-world</span>
<span class="sd">        court coordinate system, in meters.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function applies an inverse transformation, converting image coordinates into</span>
<span class="sd">    real-world court coordinates by applying translation and scaling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># using homogenous transformation</span>
    <span class="n">t_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RF_Img</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">RF_Img</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>  <span class="c1"># * scale</span>

    <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">img_pnt</span><span class="p">,</span> <span class="n">t_mtx</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>

    <span class="k">return</span> <span class="n">new_point</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span></div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Marco Bonan
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=f90d2953"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    </body>
</html>